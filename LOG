01:24:21 [WARN] Adapter is not Vulkan compliant, hiding adapter: Microsoft Direct3D12 (Intel(R) Arc(TM) Graphics)
01:24:21 [WARN] Adapter is not Vulkan compliant, hiding adapter: Microsoft Direct3D12 (NVIDIA GeForce RTX 4050 Laptop GPU)
01:24:21 [WARN] Adapter is not Vulkan compliant, hiding adapter: Microsoft Direct3D12 (Microsoft Basic Render Driver)
01:24:21 [WARN] Missing downlevel flags: DownlevelFlags(VERTEX_AND_INSTANCE_INDEX_RESPECTS_RESPECTIVE_FIRST_VALUE_IN_INDIRECT_DRAW)
The underlying API or device in use does not support enough features to be a fully compliant implementation of WebGPU. A subset of the features can still be used. If you are running this program on native and not in a browser and wish to limit the features you use to the supported subset, call Adapter::downlevel_properties or Device::downlevel_properties to get a listing of the features the current platform supports.
01:24:21 [WARN] DownlevelCapabilities {
    flags: DownlevelFlags(
        COMPUTE_SHADERS | FRAGMENT_WRITABLE_STORAGE | INDIRECT_EXECUTION | BASE_VERTEX | READ_ONLY_DEPTH_STENCIL | NON_POWER_OF_TWO_MIPMAPPED_TEXTURES | CUBE_ARRAY_TEXTURES | COMPARISON_SAMPLERS | INDEPENDENT_BLEND | VERTEX_STORAGE | ANISOTROPIC_FILTERING | FRAGMENT_STORAGE | MULTISAMPLED_SHADING | DEPTH_TEXTURE_AND_BUFFER_COPIES | WEBGPU_TEXTURE_FORMAT_SUPPORT | BUFFER_BINDINGS_NOT_16_BYTE_ALIGNED | UNRESTRICTED_INDEX_BUFFER | FULL_DRAW_INDEX_UINT32 | DEPTH_BIAS_CLAMP | VIEW_FORMATS | UNRESTRICTED_EXTERNAL_TEXTURE_COPIES | SURFACE_VIEW_FORMATS | NONBLOCKING_QUERY_RESOLVE,
    ),
    limits: DownlevelLimits,
    shader_model: Sm5,
}
01:24:21 [INFO] Naga generated shader for "main" at Compute:
struct OffsetPc {
    uint inner;
};

RWByteAddressBuffer dst_ : register(u0);
ByteAddressBuffer src : register(t0);
ConstantBuffer<OffsetPc> offset: register(b0);

typedef uint ret_Constructarray6_uint_[6];
ret_Constructarray6_uint_ Constructarray6_uint_(uint arg0, uint arg1, uint arg2, uint arg3, uint arg4, uint arg5) {
    uint ret[6] = { arg0, arg1, arg2, arg3, arg4, arg5 };
    return ret;
}

[numthreads(1, 1, 1)]
void main()
{
    uint _e3 = offset.inner;
    uint _e5 = asuint(src.Load(_e3*4));
    uint _e9 = offset.inner;
    uint _e13 = asuint(src.Load((_e9 + 1u)*4));
    uint _e17 = offset.inner;
    uint _e21 = asuint(src.Load((_e17 + 2u)*4));
    uint3 src_1 = uint3(_e5, _e13, _e21);
    if ((((src_1.x > 65535u) || (src_1.y > 65535u)) || (src_1.z > 65535u))) {
        {
            uint _value3[6] = Constructarray6_uint_(0u, 0u, 0u, 0u, 0u, 0u);
            dst_.Store(0, asuint(_value3[0]));
            dst_.Store(4, asuint(_value3[1]));
            dst_.Store(8, asuint(_value3[2]));
            dst_.Store(12, asuint(_value3[3]));
            dst_.Store(16, asuint(_value3[4]));
            dst_.Store(20, asuint(_value3[5]));
        }
        return;
    } else {
        {
            uint _value3[6] = Constructarray6_uint_(src_1.x, src_1.y, src_1.z, src_1.x, src_1.y, src_1.z);
            dst_.Store(0, asuint(_value3[0]));
            dst_.Store(4, asuint(_value3[1]));
            dst_.Store(8, asuint(_value3[2]));
            dst_.Store(12, asuint(_value3[3]));
            dst_.Store(16, asuint(_value3[4]));
            dst_.Store(20, asuint(_value3[5]));
        }
        return;
    }
}

01:24:21 [INFO] Naga generated shader for "vs_main" at Vertex:
struct NagaConstants {
    int first_vertex;
    int first_instance;
    uint other;
};
ConstantBuffer<NagaConstants> _NagaConstants: register(b0);

struct FragmentInput_fs_main {
    float4 position_1 : SV_Position;
};

float4 vs_main(float4 vertex : LOC0) : SV_Position
{
    return vertex;
}

float4 fs_main(FragmentInput_fs_main fragmentinput_fs_main) : SV_Target0
{
    float4 position = fragmentinput_fs_main.position_1;
    return float4(1.0, 1.0, 1.0, 1.0);
}

01:24:21 [INFO] Naga generated shader for "fs_main" at Fragment:
struct NagaConstants {
    int first_vertex;
    int first_instance;
    uint other;
};
ConstantBuffer<NagaConstants> _NagaConstants: register(b0);

struct FragmentInput_fs_main {
    float4 position_1 : SV_Position;
};

float4 vs_main(float4 vertex : LOC0) : SV_Position
{
    return vertex;
}

float4 fs_main(FragmentInput_fs_main fragmentinput_fs_main) : SV_Target0
{
    float4 position = fragmentinput_fs_main.position_1;
    return float4(1.0, 1.0, 1.0, 1.0);
}

01:24:21 [ERROR] Handling wgpu errors as fatal by default
